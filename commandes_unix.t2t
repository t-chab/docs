Guide de survie sous Unix
<tchabaud@sqli.com>
Dernière mise à jour: %%mtime(%c)

%! Target : xhtml
%! Encoding: utf-8
%! Options : --toc --enum-title
%!preproc: URLWIKIVIM       http://fr.wikipedia.org/wiki/Vim
%!preproc: URLWIKIBASH      http://fr.wikipedia.org/wiki/Bourne-Again_shell
%!preproc: URLBOOKMARKCHEAT http://www.cyberciti.biz/tips/linux-unix-commands-cheat-sheets.html
%!preproc: URLAWKTUTO http://nyal.developpez.com/tutoriel/gawk/index.php

= Commandes Unix =
====================

%%TOC.

====================

+ Shell +
L'appellation //shell// désigne la plupart du temps dans le monde Unix un interpréteur de lignes de commandes. Pour des raisons de concision, cette documentation ne traite que du shell //bash//, qui est utilisé par défaut sur les distributions Linux et Mac OS X.
Les principaux raccourcis clavier du shell //bash// sont les suivants :

Complète la commande
``` Tab
ou
``` Ctrl-i
Déconnecte l'utilisateur (équivalent d'un //exit//)
``` Ctrl-d
Efface l'écran (équivalent de la commande //clear//)
``` Ctrl-l
Envoie le curseur en début de ligne
``` Ctrl-a
Envoie le curseur en fin de ligne
``` Ctrl-e
Commande précédente dans l'historique
``` Ctrl-p
Commande suivante dans l'historique
``` Ctrl-n
Rappelle la dernière commande commençant par //uneChaine//
``` !uneChaine
Interrompt la commande en cours
``` Ctrl-c
Met en pause le process courant (envoi d'un signal **SIGSTP**). Il faut utiliser la commande //fg// pour le reprendre.
``` Ctrl-z

+ Documentation +

++ man ++

La commande //man// permet d'afficher le manuel d'utilisation de la commande passé en argument.

**__Exemple__** :
    Affiche l'aide de la commande //ls//, avec le détail des options.
``` man ls
    Convertit le manuel de la commande //bash// en fichier Postscript.
``` man -t bash > bash.ps
    Convertit le manuel de la commande //bash// en fichier PDF.
``` man -t bash | ps2pdf - > bash.pdf

+ Gestion des fichiers +

++ pwd ++

La commande //pwd// affiche le répertoire courant.

++ cd ++

La commande //cd// permet de se déplacer dans le répertoire passé en argument.
Le caractère //-// permet de revenir au répertoire précédent. Le caractère //~// pointe vers le répertoire //home// de l'utilisateur courant.

**__Exemple :__** :
    Le répertoire courant devient ///usr// puis ///var// puis on revient ensuite dans le répertoire ///usr// avant de se déplacer dans le //home// de l'utilisateur.
``` cd /usr
``` cd /var
``` cd -
``` cd ~

++ ls ++

La commande //ls// permet de lister le contenu d'un répertoire.

**__Exemple :__**
    Liste tous les fichiers (//-a//, c'est à dire même les fichiers cachés) avec un affichage détaillé (//-l//) en les triant par date (//-t//) du plus ancien au plus récent (//-r//, inverse l'ordre de tri).
``` ls -alrt
    Liste tous les fichiers du répertoire ///var// mais n'affiche pas //.// (alias pour le répertoire courant) ni //../// (alias pour le répertoire parent)    
``` ls -A /var

++ mv ++

La commande //mv// permet de renommer des fichiers / répertoires.

**__Exemple :__**
    Renomme le fichier //http.conf// en //httpd.conf//
``` mv http.conf httpd.conf

++ cp ++

La commande //cp// permet de copier des fichiers / répertoires.

**__Exemple :__**
    Copie le contenu de //ficsrc// dans un second fichier nommé //ficdest//
``` cp ficsrc ficdest

++ find ++

La commande //find// Permet de rechercher des fichiers dans l'arborescence du système de fichiers.

**__Exemple :__**
    Recherche dans le répertoire ///usr// et dans tous ses sous répertoires tous les fichiers (-type f) dont le nom commence par //foo//
``` find /usr -type f -name "foo*"
    Recherche dans le répertoire ///home// (~) de l'utilisateur tous les élément qui se terminent par //.jpg// et
    exécute sur chaque élément trouvé la commande //convert <fichier>//
``` find ~ -name "*.jpg" -exec convert {} basename \{\} .png

+ Manipulation de fichiers textes +

++ grep ++

La commande //grep// permet d'effectuer des recherches de chaine de caractères dans des fichiers. La syntaxe est simple :
``` grep [chaine de recherche] [fichier ou répertoire]
Les options les plus pratiques sont les suivantes :
- -R : permet d'effectuer une recherche récursivement dans un répertoire
- -i : permet d'ignorer la casse
- -c : Supprime la sortie standard et affiche à la place le nombre de lignes correspondantes à la chaine de recherche dans chaque fichier en entrée.
- -A //N// : Affiche les //N// lignes  qui précédent chaque occurence de recherche.
- -B //N// : Idem que //-A// pour les lignes qui suivent chaque occurence de recherche.
- -C //N// : Affiche //N// lignes entourant l'occurence de recherche.


Pour ces 3 dernières options, chaque groupe de lignes est séparé par la chaine //--//.

++ awk ++

La commande //awk// permet de nombreuses manipulations sur des fichiers textes. Un tutoriel est disponible ici
[URLAWKTUTO]. Elle est très pratique pour réordonner les colonnes d'un fichier texte, ou le filtrer en n'affichant que certaines
colonnes. Les colonnes sont référencées par //$<index>//. Par exemple la colonne 3 est référencée par //$3//. //$0//
référence l'ensemble des colonnes d'une ligne. Le séparateur de champs par défaut est le caractère espace.

**__Syntaxe "one-line" :__**
``` awk -F "<séparateur>" '{ suite de commandes [...] }'

**__Exemple__** :
    Affiche la 4e et la 8e colonne du fichier //foo.csv// ayant comme séparateur de champ le caractère //;//
    Les 2 colonnes sont séparées par le caractère espace.
``` awk -F ";" '{ print $4 " " $8}' foo.csv
    Affiche le fichier system.log sans les 3 premières colonnes.
``` awk '{ print $1=$2=$3=""; print $0}' system.log

++ vim ++

+++ Description  +++

Vim est un éditeur de texte descendant de vi, et qui dispose de plusieurs modes d'éditions. Les plus utilisés sont le mode commande et le mode insertion.

Vim démarre en mode commande, qui permet notamment de sauvegarder, d'effectuer des recherches, copier du texte, etc ...

Pour passer du mode commande au mode édition, il faut utiliser la touche **i**.
La touche **Echap** permet de retourner au mode commande depuis le mode édition.
Pour saisir une commande dans le mode éponyme, il faut utiliser la syntaxe //:<commande>//

+++ Commandes principales +++

Pour sauvegarder
``` :w
Pour quitter
``` :q
Pour sauvegarder et quitter
``` :wq
Pour chercher la chaine "toto" dans le fichier courant
``` :/toto
Envoie le curseur en fin de fichier
``` :$
Positionne le curseur sur la ligne 15 du fichier courant
``` :15
Utilise des fins de ligne Unix (\n) pour le fichier courant. Pour utiliser des fins de lignes DOS (\r\n), remplacer //unix// par
//dos//
``` :set ff=unix
Supprime la ligne courante
``` :dd
Efface 20 lignes à partir du curseur
``` :d20
Active la coloration syntaxique (//off// pour désactiver).
``` :set syntax on
Active un jeu de couleur (pour la coloration syntaxique) plus lisible pour les terminaux à fond sombre.
``` :set background=dark
Affiche les numéros de lignes. //nonumber// pour les masquer.
``` :set number

+++ Raccourcis claviers +++

Raccourcis clavier du mode commande :

- //x// : Supprime le caractère sous le curseur.
- //j// : Déplace le curseur sur la ligne du dessous.
- //k// : Déplace le curseur sur la ligne du dessus.
- //h// : Déplace le curseur d'un caractère vers la gauche.
- //l// : Déplace le curseur d'un caractère vers la droite.
- //A// : Envoie le curseur a la fin de la ligne courante et bascule en mode insertion.
- //u// : Undo. Annule la dernière commande. //u<N>// Permet d'annuler les //<N>// dernières commandes.


+++ Copier/coller  +++

- Positionner le curseur au début de la zone à copier ou couper.
- Appuyer sur //v// pour débuter la sélection.
- Déplacer le curseur à la fin de la zone à copier ou couper.
- Appuyer sur //d// (delete) pour couper ou sur //y// (yank) pour copier.
- Déplacer le curseur vers la zone cible de la copie ou du déplacement.
- Appuyer sur //p// pour coller après le curseur ou //P// pour coller avant le curseur.


+ Notion de pipe +

Le pipe (caractère |) permet de brancher la sortie d'une commande sur l'entrée d'une autre, afin d'enchainer des traitements, par exemple de filtrer un fichier texte :

**__Exemple :__**
Recherche la chaine //2012/08/01// dans le fichier access.log. La sortie du grep est ensuite branchée sur la commande
awk qui va afficher les colonnes 15 et 1 de la sortie, séparée par un espace. Pour finir on se branche sur la commande
//sort// qui va trier le tout par ordre décroissant (option //r//) en effectuant un tri numérique (option //n//).
``` grep "2012/08/01" access.log | awk '{ print $15 " " $1}' |sort -rn

====================

+ Remerciements +

Merci à N. Boussedra, D. Guérin, L. Courvoisier et G. Euzet pour leurs suggestions.

====================

+ Bibliographie +

- [URLWIKIVIM]
- [URLWIKIBASH]
- [URLBOOKMARKCHEAT]

